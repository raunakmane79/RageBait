<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Unfair Tetris — Starts Fair, Ends Evil</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap" rel="stylesheet">
<style>
  :root{
    --bg:#0b0c10; --panel:#0f121a; --line:#1b2030; --ink:#eef1f6; --muted:#aab0c0;
    --accent:#7c5cff; --danger:#ff4e73; --bad:#ffb870;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif; color:var(--ink);
    background:radial-gradient(1200px 800px at 20% -10%, #151a26, #0b0c10);
    display:flex; align-items:center; justify-content:center; padding:16px;
  }
  .wrap{display:grid; grid-template-columns:auto 220px; gap:14px; width:min(900px,96vw)}
  .card{
    padding:12px; border:1px solid var(--line); border-radius:14px;
    background:linear-gradient(180deg,#0f121a,#0b0c10);
    box-shadow:0 20px 60px rgba(0,0,0,.45), inset 0 0 0 1px rgba(255,255,255,.03);
  }
  header{display:flex; justify-content:space-between; align-items:center; margin-bottom:8px}
  .title{font-weight:900; letter-spacing:.02em}
  .badge{font-size:.8rem; font-weight:800; padding:6px 10px; border-radius:999px; white-space:nowrap;
    background:linear-gradient(135deg, var(--accent), #4b89ff);}
  canvas{display:block; background:#0a0d18; border-radius:10px; touch-action:none}
  .hud{display:flex; flex-direction:column; gap:8px}
  .pill{padding:8px 10px; border:1px solid var(--line); border-radius:12px; color:var(--muted)}
  .grid{display:grid; grid-template-columns:repeat(3,1fr); gap:8px; margin-top:8px}
  .btn{
    padding:10px 12px; border-radius:12px; border:1px solid var(--line); background:#0f1322;
    color:var(--ink); font-weight:800; letter-spacing:.02em; text-align:center; user-select:none; cursor:pointer;
  }
  .btn:active{transform:scale(.98)}
  .wide{grid-column:1/-1}
  .toast{
    position:fixed; left:50%; top:12px; transform:translateX(-50%) translateY(-8px);
    background:#121622; border:1px solid var(--line); color:var(--muted);
    padding:10px 14px; border-radius:12px; font-weight:800; opacity:0; pointer-events:none;
    transition:opacity .25s, transform .25s;
    white-space:nowrap;
  }
  .toast.show{opacity:1; transform:translateX(-50%) translateY(0)}
</style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <header>
      <div class="title">Unfair Tetris — <span style="opacity:.8">starts normal</span></div>
      <div id="mode" class="badge">Normal</div>
    </header>
    <canvas id="game" width="300" height="600"></canvas>
  </div>

  <div class="card hud">
    <div class="pill">Score: <b id="score">0</b></div>
    <div class="pill">Lines: <b id="lines">0</b></div>
    <div class="pill">Level: <b id="level">1</b></div>
    <div class="pill">Status: <b id="status">Ready</b></div>
    <div class="pill">Controls: ⬅️➡️ move, ⬆️/Z/X rotate, ⬇️ drop, Space hard-drop</div>
    <div class="grid">
      <div id="left"  class="btn">◀︎</div>
      <div id="down"  class="btn">▼</div>
      <div id="right" class="btn">▶︎</div>
      <div id="rotL"  class="btn">⟲</div>
      <div id="hard"  class="btn">⤓</div>
      <div id="rotR"  class="btn">⟳</div>
      <div id="restart" class="btn wide">Restart</div>
    </div>
  </div>
</div>

<div id="toast" class="toast">Unfair Mode: ON</div>

<script>
(() => {
  // ===== DOM refs
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const linesEl = document.getElementById('lines');
  const levelEl = document.getElementById('level');
  const statusEl= document.getElementById('status');
  const modeEl  = document.getElementById('mode');
  const toast   = document.getElementById('toast');

  // touch buttons
  const $ = id => document.getElementById(id);
  $('left').onclick  = () => move(-1);
  $('right').onclick = () => move(1);
  $('down').onclick  = () => softDrop();
  $('rotL').onclick  = () => rotate(-1);
  $('rotR').onclick  = () => rotate(1);
  $('hard').onclick  = () => hardDrop();
  $('restart').onclick = () => restart();

  // ===== Game constants
  const COLS = 10, ROWS = 20, SIZE = Math.floor(canvas.height / ROWS);
  canvas.width  = COLS * SIZE;
  canvas.height = ROWS * SIZE;

  const COLOR = {
    0:'#0a0d18', 1:'#00f0f0',2:'#0000f0',3:'#f0a000',4:'#f0f000',5:'#00f000',6:'#f00000',7:'#a000f0', 8:'#48506a' // junk
  };
  const SHAPES = {
    I:[[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
    J:[[2,0,0],[2,2,2],[0,0,0]],
    L:[[0,0,3],[3,3,3],[0,0,0]],
    O:[[4,4],[4,4]],
    S:[[0,5,5],[5,5,0],[0,0,0]],
    Z:[[6,6,0],[0,6,6],[0,0,0]],
    T:[[0,7,0],[7,7,7],[0,0,0]]
  };
  const BAG = ['I','J','L','O','S','Z','T'];

  // ===== State
  let board, piece, queue, score, lines, level, running;
  let dropMs, dropAcc, lastT;
  let unfair=false, unfairAtMs, junkEveryMs, lastJunk;

  function newBoard(){
    return Array.from({length:ROWS},()=>Array(COLS).fill(0));
  }
  function bag(){
    const b = BAG.slice();
    for(let i=b.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [b[i],b[j]]=[b[j],b[i]]; }
    return b;
  }
  function makePiece(t){ return {m:SHAPES[t].map(r=>r.slice()), x:(COLS>>1)-2, y:-2}; }

  function restart(){
    board = newBoard();
    queue = bag();
    piece = makePiece(queue.shift());
    score=0; lines=0; level=1; running=true;
    dropMs=800; dropAcc=0; lastT=0;
    unfair=false; unfairAtMs=performance.now()+15000; junkEveryMs=900; lastJunk=0;
    modeEl.textContent='Normal';
    modeEl.style.background='linear-gradient(135deg, var(--accent), #4b89ff)';
    statusEl.textContent='Ready';
    updateHUD(); draw();
    requestAnimationFrame(loop);
  }

  function rotate(dir){
    const m=piece.m;
    // transpose
    for(let y=0;y<m.length;y++){ for(let x=0;x<y;x++){ [m[x][y],m[y][x]]=[m[y][x],m[x][y]]; } }
    // reverse
    if (dir>0) m.forEach(r=>r.reverse()); else m.reverse();
    // kick
    if (collide(board,piece)){ piece.x++; if (collide(board,piece)){ piece.x-=2; if (collide(board,piece)){ piece.x++; // revert
      if (dir>0){ m.reverse(); m.forEach(r=>r.reverse()); } else { m.forEach(r=>r.reverse()); m.reverse(); } } } }
  }

  function move(dx){ piece.x+=dx; if (collide(board,piece)) piece.x-=dx; }
  function softDrop(){
    piece.y++;
    if (collide(board,piece)){ piece.y--; lock(); clearLines(); spawn(); }
  }
  function hardDrop(){ while(!collide(board,piece)) piece.y++; piece.y--; lock(); clearLines(); spawn(); }

  function collide(mat,p){
    const m=p.m;
    for(let y=0;y<m.length;y++){
      for(let x=0;x<m[y].length;x++){
        if (!m[y][x]) continue;
        const nx=p.x+x, ny=p.y+y;
        if (ny<0) continue;
        if (nx<0 || nx>=COLS || ny>=ROWS) return true;
        if (mat[ny][nx]) return true;
      }
    }
    return false;
  }

  function lock(){
    const m=piece.m;
    for(let y=0;y<m.length;y++) for(let x=0;x<m[y].length;x++){
      if (m[y][x]){
        const nx=piece.x+x, ny=piece.y+y;
        if (ny>=0) board[ny][nx]=m[y][x];
      }
    }
  }

  function clearLines(){
    let cleared=0;
    for(let y=ROWS-1;y>=0;y--){
      if (board[y].every(v=>v!==0)){
        board.splice(y,1);
        board.unshift(Array(COLS).fill(0));
        cleared++; y++;
      }
    }
    if (cleared){
      const pts=[0,40,100,300,1200][cleared]||cleared*300;
      score+=pts*level; lines+=cleared; level=Math.min(20,1+Math.floor(lines/10));
      dropMs=Math.max(90, 800-(level-1)*40);
      updateHUD();
      if (!unfair && (lines>=6 || score>=1000)) enableUnfair();
    }
  }

  function spawn(){
    if (queue.length<4) queue.push(...bag());
    piece = makePiece(queue.shift());
    if (collide(board,piece)){ running=false; statusEl.textContent='Topped out'; toastMsg('Game Over'); }
  }

  function enableUnfair(){
    unfair=true; modeEl.textContent='Unfair';
    modeEl.style.background='linear-gradient(135deg, var(--danger), var(--bad))';
    statusEl.textContent='Random blocks invading…';
    toastMsg('Unfair Mode: ON');
    dropMs=Math.max(120, dropMs-120);
  }

  function maybeSpawnJunk(now){
    if (!unfair) return;
    if (now-lastJunk < junkEveryMs) return;
    lastJunk=now; junkEveryMs=Math.max(250, junkEveryMs-15);

    // pick a nasty spot (bias near active piece column & above it)
    const candidates=[];
    for(let y=0;y<ROWS;y++){
      for(let x=0;x<COLS;x++){
        if (board[y][x]===0) candidates.push({x,y,score: Math.abs((piece.x+1)-x) + Math.abs((piece.y+1)-y)*0.6});
      }
    }
    if (!candidates.length) return;
    candidates.sort((a,b)=>a.score-b.score);
    const c = (Math.random()<0.6) ? candidates[0] : candidates[(Math.random()*candidates.length)|0];
    board[c.y][c.x]=8;
    // occasionally nudge piece down to steal time
    if (Math.random()<0.25) softDrop();
  }

  function update(now){
    if (!running) return;
    if (!lastT) lastT=now;
    const dt = now-lastT; lastT=now;
    dropAcc+=dt;

    if (!unfair && now>=unfairAtMs) enableUnfair();
    maybeSpawnJunk(now);

    if (dropAcc>dropMs){ softDrop(); dropAcc=0; }
  }

  function draw(){
    // board
    for(let y=0;y<ROWS;y++){
      for(let x=0;x<COLS;x++){
        drawCell(x,y,board[y][x]);
      }
    }
    // active
    const m=piece.m;
    for(let y=0;y<m.length;y++){
      for(let x=0;x<m[y].length;x++){
        if (m[y][x]){
          const ny=piece.y+y;
          if (ny>=0) drawCell(piece.x+x, ny, m[y][x]);
        }
      }
    }
  }

  function drawCell(x,y,val){
    ctx.fillStyle = COLOR[val] || '#888';
    ctx.fillRect(x*SIZE,y*SIZE,SIZE,SIZE);
    // subtle grid & gloss
    if (val===0){
      ctx.strokeStyle='rgba(255,255,255,.05)';
      ctx.strokeRect(x*SIZE+0.5,y*SIZE+0.5,SIZE-1,SIZE-1);
    } else {
      ctx.fillStyle='rgba(255,255,255,.12)';
      ctx.fillRect(x*SIZE+2,y*SIZE+2,SIZE-4,Math.max(1,SIZE*0.28));
      ctx.strokeStyle='rgba(0,0,0,.25)';
      ctx.strokeRect(x*SIZE+0.5,y*SIZE+0.5,SIZE-1,SIZE-1);
    }
  }

  function updateHUD(){
    scoreEl.textContent=score;
    linesEl.textContent=lines;
    levelEl.textContent=level;
  }

  function toastMsg(t){
    toast.textContent=t; toast.classList.add('show');
    clearTimeout(toastMsg._t); toastMsg._t=setTimeout(()=>toast.classList.remove('show'),1100);
  }

  // Keyboard (non-passive so Space can prevent scroll)
  window.addEventListener('keydown', (e)=>{
    if (!running) return;
    const k = e.key.toLowerCase();
    if (k==='arrowleft' || k==='a') move(-1);
    else if (k==='arrowright' || k==='d') move(1);
    else if (k==='arrowdown' || k==='s') softDrop();
    else if (k==='arrowup' || k==='x') rotate(1);
    else if (k==='z') rotate(-1);
    else if (k===' ') { e.preventDefault(); hardDrop(); }
  }, {passive:false});

  // Touch drag to move; tap bottom to hard drop
  let lastTouch=null;
  canvas.addEventListener('touchstart',(e)=>{ lastTouch=e.touches[0]; },{passive:true});
  canvas.addEventListener('touchmove',(e)=>{
    if (!lastTouch) return;
    const t=e.touches[0];
    const dx=t.clientX-lastTouch.clientX;
    const dy=t.clientY-lastTouch.clientY;
    if (Math.abs(dx)>16){ move(dx>0?1:-1); lastTouch=t; }
    if (dy>18){ softDrop(); lastTouch=t; }
  },{passive:true});
  canvas.addEventListener('touchend', (e)=>{
    // quick tap near bottom = hard drop
    const t=lastTouch; lastTouch=null;
    if (!t) return;
    const rect=canvas.getBoundingClientRect();
    if ((t.clientY-rect.top) > rect.height*0.75) hardDrop();
  }, {passive:true});

  // RAF loop
  function loop(now){
    update(now);
    draw();
    requestAnimationFrame(loop);
  }

  restart(); // go!
})();
</script>
</body>
</html>

 
