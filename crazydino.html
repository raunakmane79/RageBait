<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Smoothâ€¦ then Sus ðŸ¦–</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;800;900&display=swap" rel="stylesheet">
<style>
  :root{
    --bg:#0c0f14; --ink:#f2f4f8; --muted:#a7afc2; --line:#1a1f2a;
    --accent:#7c5cff; --accent2:#ff4e73; --good:#7cffb0; --bad:#ffc66e;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; background:radial-gradient(1200px 800px at 20% -10%, #151a26, #0c0f14);
    color:var(--ink); font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif;
    display:grid; place-items:center; padding:12px;
  }
  .card{
    width:min(960px,96vw);
    background:linear-gradient(180deg,#0f131b,#0c0f14);
    border:1px solid var(--line); border-radius:20px; overflow:hidden;
    box-shadow:0 18px 50px rgba(0,0,0,.45), inset 0 0 0 1px rgba(255,255,255,.03);
  }
  header{
    display:flex; align-items:center; justify-content:space-between; padding:10px 14px; gap:10px;
    border-bottom:1px solid var(--line); background:linear-gradient(180deg,#111625,#0f131b);
  }
  .brand{font-weight:900; letter-spacing:.02em}
  .hud{display:flex; gap:8px; flex-wrap:wrap; color:var(--muted)}
  .chip{border:1px solid var(--line); border-radius:10px; padding:6px 10px; background:#0e121a}
  .badge{background:linear-gradient(135deg,var(--accent),var(--accent2)); color:#fff; border:none}
  #stage{display:block; width:100%; height:360px; background:#0c0f14}
  .panel{
    display:flex; align-items:center; justify-content:space-between; gap:10px;
    padding:10px 14px; border-top:1px solid var(--line); background:#0c0f14;
  }
  button{
    appearance:none; border:none; cursor:pointer; font-weight:900; letter-spacing:.02em;
    padding:10px 12px; border-radius:12px; color:#fff;
    background:linear-gradient(135deg,var(--accent),var(--accent2));
    box-shadow:0 10px 24px rgba(124,92,255,.25); transition:.18s ease;
  }
  button:hover{transform:translateY(-2px)}
  button:active{transform:translateY(0) scale(.98)}
</style>
</head>
<body>
  <div class="card" role="application" aria-label="Smooth then Trick Dino Runner">
    <header>
      <div class="brand">ðŸ¦– Smoothâ€¦ then Sus</div>
      <div class="hud">
        <div class="chip">Score: <strong id="score">0</strong></div>
        <div class="chip">Speed: <strong id="speed">1.0x</strong></div>
        <div class="chip badge"><strong id="phaseBadge">Phase: TRUST</strong></div>
      </div>
    </header>

    <canvas id="stage" width="960" height="360"></canvas>

    <div class="panel">
      <div class="chip" style="background:#0b0e16;color:var(--muted);border:1px dashed var(--line)">
        <span id="toast">Itâ€™s fair. Feel the flow. (Space/â†‘ or Tap)</span>
      </div>
      <div><button id="restart">Restart</button></div>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('stage');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const speedEl = document.getElementById('speed');
  const restartBtn = document.getElementById('restart');
  const toastEl = document.getElementById('toast');
  const phaseBadgeEl = document.getElementById('phaseBadge');

  // Constants
  const W = canvas.width, H = canvas.height;
  const BASE_GROUND_Y = H - 70;
  const GRAVITY = 2200;                // px/s^2 (weâ€™ll use dt)
  const JUMP_VELOCITY = -900;          // px/s
  const LERP = (a,b,t)=>a+(b-a)*Math.min(1,Math.max(0,t));
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));

  // Phases:
  // 0 TRUST  (0â€”12s): stable speed, fair spawns, assists
  // 1 SUS    (12â€”22s): subtle deception ramps in
  // 2 RAGE   (22s+): full unfair
  const TRUST_DUR = 12;
  const SUS_DUR   = 10;

  // Game state
  let rng, timeStart, lastT, dt, t, running;
  let dino, grounds, obstacles, bgClouds, score;
  let baseSpeed, speedTarget;
  let unfairLevel = 0; // 0 trust, 1 sus, 2 rage
  let jumpBufferTimer = 0, coyoteTimer = 0;

  // Assists (good in TRUST, taper in SUS, invert in RAGE)
  const assists = {
    coyoteMsTrust: 120,      // can still jump after leaving edge
    bufferMsTrust: 140,      // buffered input before landing
  };

  // RNG
  function makeRNG(seed=Date.now()%2147483647){
    let s = seed || 1;
    return () => (s = s * 48271 % 2147483647) / 2147483647;
  }

  function setToast(msg){ toastEl.textContent = msg; }
  function setPhaseBadge(){
    phaseBadgeEl.textContent = 'Phase: ' + (unfairLevel===0 ? 'TRUST' : unfairLevel===1 ? 'SUS' : 'RAGE');
  }

  function reset(){
    rng = makeRNG();
    timeStart = performance.now();
    lastT = timeStart;
    dt = 0; t = 0; running = true;
    score = 0;

    // Movement (px/s), we lerp to target for smooth feel
    baseSpeed = 360;
    speedTarget = 360;

    dino = {
      x: 140,
      y: BASE_GROUND_Y,
      w: 38,
      h: 44,
      vy: 0,
      scale: 1,
      grounded: true,
      blink: 0
    };

    // Background parallax (for smoothness vibe)
    bgClouds = [];
    for (let i=0;i<6;i++){
      bgClouds.push({ x: rng()*W, y: 40 + rng()*160, w: 80+ rng()*140, h: 20+ rng()*30, speedMul: .2+.5*rng(), a: .08+.07*rng() });
    }

    // One long ground
    grounds = [{x:0, y: BASE_GROUND_Y, w: W*2, falling:false, vy:0}];
    obstacles = [];

    unfairLevel = 0;
    setPhaseBadge();
    speedEl.textContent = '1.0x';
    setToast('Itâ€™s fair. Feel the flow. (Space/â†‘ or Tap)');

    jumpBufferTimer = 0;
    coyoteTimer = 0;

    requestAnimationFrame(loop);
  }

  // Input with buffer & coyote time
  function requestJump(){
    // store in buffer; will be consumed in update when allowed
    jumpBufferTimer = unfairLevel===0 ? assists.bufferMsTrust/1000 : (unfairLevel===1 ? 0.08 : 0.02);
  }
  window.addEventListener('keydown', e=>{
    if (e.code==='Space' || e.code==='ArrowUp'){ e.preventDefault(); requestJump(); }
    if (e.key.toLowerCase()==='r'){ reset(); }
  }, {passive:false});
  canvas.addEventListener('pointerdown', ()=> requestJump(), {passive:true});
  restartBtn.addEventListener('click', reset);

  function jumpNow(mult=1){
    dino.vy = JUMP_VELOCITY * mult;
    dino.grounded = false;
    coyoteTimer = 0;
  }

  // Spawners
  function spawnObstacleFair(){
    const w = 28 + rng()*42;      // 28â€“70
    const h = 32 + rng()*44;      // 32â€“76
    obstacles.push({x: W + 60, y: BASE_GROUND_Y - h, w, h, type:'fair', spiked:false});
  }
  function spawnObstacleMean(forceHuge=false){
    const huge = forceHuge || rng()<0.22;
    const w = huge ? 160 + rng()*160 : 26 + rng()*70;
    const h = huge ? 90  + rng()*140 : 28 + rng()*90;
    obstacles.push({x: W + 40, y: BASE_GROUND_Y - h, w, h, type: huge? 'HUGE':'norm', spiked: rng()<0.45});
  }
  function spawnTeleAhead(){
    obstacles.push({x: dino.x + 180, y: BASE_GROUND_Y - (40+rng()*130), w: 50+rng()*180, h: 30+rng()*120, type:'tele', spiked:true});
  }
  function carveGap(){
    const gapW = 90 + rng()*220;
    const pos  = W + 120 + rng()*260;
    grounds.push({x: pos + gapW, y: BASE_GROUND_Y, w: 600, falling:false, vy:0});
  }

  // Helpers
  function rectsIntersect(a,b){
    return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
  }

  // Update
  let obsTimer = 0, gapTimer = 0, sizeTimer = 1.5, tempoTimer = 2.0, betrayTimer = 1.2;
  function updateTimers(seconds){
    obsTimer -= seconds; gapTimer -= seconds; sizeTimer -= seconds; tempoTimer -= seconds; betrayTimer -= seconds;
    jumpBufferTimer = Math.max(0, jumpBufferTimer - seconds);
    if (!dino.grounded) coyoteTimer = Math.max(0, coyoteTimer - seconds);
  }

  function phaseLogic(secondsSinceStart){
    // Determine phase
    const old = unfairLevel;
    if (secondsSinceStart < TRUST_DUR) unfairLevel = 0;
    else if (secondsSinceStart < TRUST_DUR + SUS_DUR) unfairLevel = 1;
    else unfairLevel = 2;

    if (unfairLevel !== old){
      setPhaseBadge();
      if (unfairLevel===1) setToast('Huhâ€”did that feelâ€¦different?');
      if (unfairLevel===2) setToast('Rage Mode: ENABLED. Good luck ðŸ™‚');
    }

    // Smooth speed target changes
    if (unfairLevel===0){
      speedTarget = 360; // constant
    } else if (unfairLevel===1){
      // gentle drift between 0.9x and 1.3x
      const mul = 0.9 + 0.4 * (0.5+0.5*Math.sin(t*0.7));
      speedTarget = 360 * mul;
    } else {
      // chaotic spikes (0.7xâ€“2.5x) but smoothed into baseSpeed
      if (tempoTimer <= 0){
        tempoTimer = 1.8 + rng()*2.4;
        speedTarget = 360 * (0.7 + rng()*1.8);
        setToast(speedTarget>540 ? "Speed boost! (for me)" : (speedTarget<320 ? "Slowedâ€¦ misjudge those jumps." : "Tempo change."));
      }
    }
    baseSpeed = LERP(baseSpeed, speedTarget, 0.12); // smooth
    speedEl.textContent = (baseSpeed/360).toFixed(1)+'x';

    // Obstacles
    if (obsTimer <= 0){
      if (unfairLevel===0){
        obsTimer = 0.9 + rng()*0.7;
        spawnObstacleFair();
      } else if (unfairLevel===1){
        obsTimer = 0.75 + rng()*0.6;
        rng()<0.2 ? spawnObstacleMean(false) : spawnObstacleFair();
        if (rng()<0.06) spawnTeleAhead();
      } else {
        obsTimer = 0.5 + rng()*0.55;
        spawnObstacleMean(rng()<0.2);
        if (rng()<0.25) spawnTeleAhead();
      }
    }

    // Gaps & betrayals
    if (unfairLevel>=1 && gapTimer<=0){
      gapTimer = unfairLevel===1 ? 3.0 + rng()*2.2 : 2.0 + rng()*1.8;
      if (rng()< (unfairLevel===1 ? 0.55 : 0.9)) carveGap();
    }
    if (unfairLevel===2 && betrayTimer<=0){
      betrayTimer = 1.4 + rng()*2.2;
      // make segment underfoot fall
      const under = grounds.find(g => dino.x > g.x && dino.x < g.x+g.w && !g.falling);
      if (under){ under.falling = true; under.vy = -120; setToast("Who needs floors anyway?"); }
    }

    // Size shenanigans
    if (sizeTimer<=0){
      sizeTimer = unfairLevel===0 ? 9999 : (unfairLevel===1 ? 3.6 + rng()*2.0 : 2.0 + rng()*2.5);
      if (unfairLevel>=1){
        dino.scale = clamp(0.7 + rng()*1.4, 0.55, 2.3);
        dino.blink = 12;
        setToast(dino.scale>1.25? "Bigger target, bigger fun." : "Tiny but still doomed.");
      } else {
        dino.scale = 1;
      }
    }
  }

  function update(seconds){
    if (!running) return;

    // Phase + spawns + speeds
    phaseLogic((t - timeStart)/1000);

    // Move background clouds smoothly
    for (const c of bgClouds){
      c.x -= (baseSpeed * c.speedMul) * seconds;
      if (c.x + c.w < -20){ c.x = W + 40; c.y = 40 + rng()*160; }
    }

    // Ground movement and gravity on falling segments
    for (let i=grounds.length-1;i>=0;i--){
      const g = grounds[i];
      g.x -= baseSpeed * seconds;
      if (g.falling){
        g.vy += 900 * seconds;
        g.y += g.vy * seconds;
      }
      if (g.x + g.w < -80 || g.y > H + 240) grounds.splice(i,1);
    }
    const last = grounds[grounds.length-1];
    if (!last || last.x + last.w < W + 280){
      grounds.push({x: (last? last.x+last.w : 0), y: BASE_GROUND_Y, w: 600, falling:false, vy:0});
    }

    // Consume jump buffer with coyote-time
    const coyoteAllowed = (unfairLevel===0 ? assists.coyoteMsTrust : unfairLevel===1 ? 60 : 0) / 1000;
    if (dino.grounded) coyoteTimer = coyoteAllowed;

    if (jumpBufferTimer > 0){
      if (dino.grounded || coyoteTimer>0){
        jumpNow(unfairLevel===0 ? 1.02 : 1.0);
        jumpBufferTimer = 0;
      }
    }

    // Physics
    dino.vy += GRAVITY * seconds;
    dino.y  += dino.vy * seconds;

    // Determine ground under dino
    let groundYHere = Infinity, onGround=false;
    for (const g of grounds){
      if (dino.x + (dino.w*dino.scale*0.5) > g.x && dino.x - (dino.w*dino.scale*0.5) < g.x + g.w){
        groundYHere = Math.min(groundYHere, g.y);
      }
    }
    const standY = groundYHere - dino.h*dino.scale;
    if (dino.y >= standY){
      dino.y = standY;
      dino.vy = 0;
      onGround = isFinite(groundYHere);
    }
    dino.grounded = onGround;

    // Obstacles move
    for (let i=obstacles.length-1;i>=0;i--){
      const o = obstacles[i];
      const mul = o.type==='tele' ? 1.25 : 1;
      o.x -= baseSpeed * mul * seconds;
      if (o.x + o.w < -80) obstacles.splice(i,1);
    }

    // Score
    score += baseSpeed * 0.6 * seconds;
    scoreEl.textContent = Math.floor(score);

    // Collisions
    const hitbox = {
      x: dino.x - (dino.w*dino.scale*0.5),
      y: dino.y,
      w: dino.w*dino.scale,
      h: dino.h*dino.scale
    };
    if (!isFinite(groundYHere) || dino.y > H + 60) return gameOver("Mind the gap.");
    for (const o of obstacles){
      if (rectsIntersect(hitbox, o)){
        return gameOver(
          o.type==='HUGE' ? "Crushed by â€˜fairâ€™ design."
          : o.type==='tele' ? "Spawn-camped."
          : (unfairLevel===0 ? "Watch your step." : "Bonk.")
        );
      }
    }
  }

  // Draw
  function draw() {
    // bg
    ctx.fillStyle = '#0c0f14';
    ctx.fillRect(0,0,W,H);

    // clouds (parallax)
    for (const c of bgClouds){
      ctx.globalAlpha = c.a;
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.roundRect(c.x, c.y, c.w, c.h, 10);
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    // subtle grid
    ctx.strokeStyle = 'rgba(255,255,255,.05)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    for (let x=0;x<W;x+=32){ ctx.moveTo(x,0); ctx.lineTo(x,H); }
    for (let y=0;y<H;y+=32){ ctx.moveTo(0,y); ctx.lineTo(W,y); }
    ctx.stroke();

    // Grounds
    for (const g of grounds){
      const grad = ctx.createLinearGradient(0,g.y,0,g.y+8);
      grad.addColorStop(0,'#172134'); grad.addColorStop(1,'#0e1422');
      ctx.fillStyle = grad;
      ctx.fillRect(g.x, g.y, g.w, 8);
      ctx.fillStyle = '#0a0f1b';
      ctx.fillRect(g.x, g.y+8, g.w, H - (g.y+8));
    }

    // Obstacles
    for (const o of obstacles){
      ctx.fillStyle = o.type==='HUGE' ? '#ff4e73' : (o.type==='tele' ? '#7c5cff' : '#c3d0ff');
      ctx.fillRect(o.x, o.y, o.w, o.h);
      if (o.spiked){
        ctx.fillStyle = 'rgba(255,255,255,.85)';
        for (let i=0;i<o.w;i+=12){
          ctx.beginPath();
          ctx.moveTo(o.x+i, o.y);
          ctx.lineTo(o.x+i+6, o.y-8);
          ctx.lineTo(o.x+i+12, o.y);
          ctx.fill();
        }
      }
    }

    // Dino
    ctx.save();
    ctx.translate(dino.x, dino.y);
    ctx.scale(dino.scale, dino.scale);
    // body
    ctx.fillStyle = '#8be88b';
    ctx.beginPath();
    ctx.roundRect(-dino.w*0.5, 0, dino.w, dino.h, 6);
    ctx.fill();
    // legs
    ctx.fillStyle = '#6cd46c';
    ctx.fillRect(-dino.w*0.45, dino.h-6, 10, 6);
    ctx.fillRect(dino.w*0.15, dino.h-6, 10, 6);
    // tail
    ctx.fillStyle = '#74dd74';
    ctx.beginPath();
    ctx.moveTo(dino.w*0.5, dino.h*0.2);
    ctx.lineTo(dino.w*0.82, dino.h*0.02);
    ctx.lineTo(dino.w*0.5, dino.h*0.4);
    ctx.fill();
    // eye
    ctx.fillStyle = '#0c0f14';
    const eyeOpen = dino.blink-- > 0 ? 1 : (Math.sin(performance.now()/220) > -0.5 ? 1 : 0.2);
    ctx.beginPath();
    ctx.arc(-dino.w*0.15, dino.h*0.22, 3*eyeOpen, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  // Loop (delta-time based for smoothness)
  function loop(now){
    if (!running) return;
    t = now;
    dt = (now - lastT) / 1000;
    lastT = now;

    // clamp dt to avoid big jumps on tab-switch
    dt = Math.min(dt, 1/20);

    updateTimers(dt);
    update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  function gameOver(reason){
    running = false;
    setToast(reason + ' â€” Press R or Restart');
    ctx.fillStyle = 'rgba(0,0,0,.55)';
    ctx.fillRect(0,0,W,H);
    ctx.fillStyle = '#fff';
    ctx.font = '900 28px Inter, system-ui, sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Game Over', W/2, H/2 - 6);
    ctx.font = '700 14px Inter, system-ui, sans-serif';
    ctx.fillStyle = '#a7afc2';
    ctx.fillText(reason, W/2, H/2 + 18);
  }

  // Start
  reset();
})();
</script>
</body>
</html>
          